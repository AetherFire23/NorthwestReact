//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.3.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class Client {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param playerGuid (optional)
     * @param newRoomGuid (optional)
     * @return Success
     */
    createChatroom(playerGuid: string | undefined, newRoomGuid: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Chat/CreateChatroom?";
        if (playerGuid === null)
            throw new Error("The parameter 'playerGuid' cannot be null.");
        else if (playerGuid !== undefined)
            url_ += "playerGuid=" + encodeURIComponent("" + playerGuid) + "&";
        if (newRoomGuid === null)
            throw new Error("The parameter 'newRoomGuid' cannot be null.");
        else if (newRoomGuid !== undefined)
            url_ += "newRoomGuid=" + encodeURIComponent("" + newRoomGuid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateChatroom(_response);
        });
    }

    protected processCreateChatroom(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param playerId (optional)
     * @param roomToLeave (optional)
     * @return Success
     */
    leaveChatRoom(playerId: string | undefined, roomToLeave: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Chat/LeaveChatRoom?";
        if (playerId === null)
            throw new Error("The parameter 'playerId' cannot be null.");
        else if (playerId !== undefined)
            url_ += "playerId=" + encodeURIComponent("" + playerId) + "&";
        if (roomToLeave === null)
            throw new Error("The parameter 'roomToLeave' cannot be null.");
        else if (roomToLeave !== undefined)
            url_ += "roomToLeave=" + encodeURIComponent("" + roomToLeave) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLeaveChatRoom(_response);
        });
    }

    protected processLeaveChatRoom(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param guid (optional)
     * @param roomId (optional)
     * @param receivedMessage (optional)
     * @return Success
     */
    putNewMessageToServer(guid: string | undefined, roomId: string | undefined, receivedMessage: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/Chat/PutNewMessageToServer?";
        if (guid === null)
            throw new Error("The parameter 'guid' cannot be null.");
        else if (guid !== undefined)
            url_ += "guid=" + encodeURIComponent("" + guid) + "&";
        if (roomId === null)
            throw new Error("The parameter 'roomId' cannot be null.");
        else if (roomId !== undefined)
            url_ += "roomId=" + encodeURIComponent("" + roomId) + "&";
        if (receivedMessage === null)
            throw new Error("The parameter 'receivedMessage' cannot be null.");
        else if (receivedMessage !== undefined)
            url_ += "receivedMessage=" + encodeURIComponent("" + receivedMessage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPutNewMessageToServer(_response);
        });
    }

    protected processPutNewMessageToServer(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param playerId (optional)
     * @param lastTimeStamp (optional)
     * @return Success
     */
    gameState(playerId: string | undefined, lastTimeStamp: Date | undefined): Promise<GameState> {
        let url_ = this.baseUrl + "/gamecontroller/GameState?";
        if (playerId === null)
            throw new Error("The parameter 'playerId' cannot be null.");
        else if (playerId !== undefined)
            url_ += "playerId=" + encodeURIComponent("" + playerId) + "&";
        if (lastTimeStamp === null)
            throw new Error("The parameter 'lastTimeStamp' cannot be null.");
        else if (lastTimeStamp !== undefined)
            url_ += "lastTimeStamp=" + encodeURIComponent(lastTimeStamp ? "" + lastTimeStamp.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGameState(_response);
        });
    }

    protected processGameState(response: Response): Promise<GameState> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = GameState.fromJS(resultData200, _mappings);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GameState>(null as any);
    }

    /**
     * @param playerId (optional)
     * @param taskCode (optional)
     * @param body (optional)
     * @return Success
     */
    executeGameTask(playerId: string | undefined, taskCode: GameTaskCodes | undefined, body: StringStringTuple[] | undefined): Promise<void> {
        let url_ = this.baseUrl + "/gamecontroller/ExecuteGameTask?";
        if (playerId === null)
            throw new Error("The parameter 'playerId' cannot be null.");
        else if (playerId !== undefined)
            url_ += "playerId=" + encodeURIComponent("" + playerId) + "&";
        if (taskCode === null)
            throw new Error("The parameter 'taskCode' cannot be null.");
        else if (taskCode !== undefined)
            url_ += "taskCode=" + encodeURIComponent("" + taskCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processExecuteGameTask(_response);
        });
    }

    protected processExecuteGameTask(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param playerId (optional)
     * @param x (optional)
     * @param y (optional)
     * @return Success
     */
    updatePlayerPosition(playerId: string | undefined, x: number | undefined, y: number | undefined): Promise<void> {
        let url_ = this.baseUrl + "/gamecontroller/UpdatePlayerPosition?";
        if (playerId === null)
            throw new Error("The parameter 'playerId' cannot be null.");
        else if (playerId !== undefined)
            url_ += "playerId=" + encodeURIComponent("" + playerId) + "&";
        if (x === null)
            throw new Error("The parameter 'x' cannot be null.");
        else if (x !== undefined)
            url_ += "x=" + encodeURIComponent("" + x) + "&";
        if (y === null)
            throw new Error("The parameter 'y' cannot be null.");
        else if (y !== undefined)
            url_ += "y=" + encodeURIComponent("" + y) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdatePlayerPosition(_response);
        });
    }

    protected processUpdatePlayerPosition(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param targetId (optional)
     * @param ownerId (optional)
     * @param itemId (optional)
     * @param gameId (optional)
     * @return Success
     */
    transferItem(targetId: string | undefined, ownerId: string | undefined, itemId: string | undefined, gameId: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/gamecontroller/TransferItem?";
        if (targetId === null)
            throw new Error("The parameter 'targetId' cannot be null.");
        else if (targetId !== undefined)
            url_ += "targetId=" + encodeURIComponent("" + targetId) + "&";
        if (ownerId === null)
            throw new Error("The parameter 'ownerId' cannot be null.");
        else if (ownerId !== undefined)
            url_ += "ownerId=" + encodeURIComponent("" + ownerId) + "&";
        if (itemId === null)
            throw new Error("The parameter 'itemId' cannot be null.");
        else if (itemId !== undefined)
            url_ += "itemId=" + encodeURIComponent("" + itemId) + "&";
        if (gameId === null)
            throw new Error("The parameter 'gameId' cannot be null.");
        else if (gameId !== undefined)
            url_ += "gameId=" + encodeURIComponent("" + gameId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTransferItem(_response);
        });
    }

    protected processTransferItem(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param playerId (optional)
     * @param targetRoomName (optional)
     * @return Success
     */
    changeRoom(playerId: string | undefined, targetRoomName: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/gamecontroller/ChangeRoom?";
        if (playerId === null)
            throw new Error("The parameter 'playerId' cannot be null.");
        else if (playerId !== undefined)
            url_ += "playerId=" + encodeURIComponent("" + playerId) + "&";
        if (targetRoomName === null)
            throw new Error("The parameter 'targetRoomName' cannot be null.");
        else if (targetRoomName !== undefined)
            url_ += "targetRoomName=" + encodeURIComponent("" + targetRoomName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "PUT",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processChangeRoom(_response);
        });
    }

    protected processChangeRoom(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param userId (optional)
     * @return Success
     */
    getMainMenuState(userId: string | undefined): Promise<MainMenuState> {
        let url_ = this.baseUrl + "/mainmenu/GetMainMenuState?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMainMenuState(_response);
        });
    }

    protected processGetMainMenuState(response: Response): Promise<MainMenuState> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = MainMenuState.fromJS(resultData200, _mappings);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MainMenuState>(null as any);
    }

    /**
     * @param userId (optional)
     * @return Success
     */
    createLobby(userId: string | undefined): Promise<Lobby> {
        let url_ = this.baseUrl + "/mainmenu/CreateLobby?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateLobby(_response);
        });
    }

    protected processCreateLobby(response: Response): Promise<Lobby> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = Lobby.fromJS(resultData200, _mappings);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Lobby>(null as any);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    joinLobby(body: JoinLobbyRequest | undefined): Promise<void> {
        let url_ = this.baseUrl + "/mainmenu/joinLobby";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processJoinLobby(_response);
        });
    }

    protected processJoinLobby(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param lobbyId (optional)
     * @return Success
     */
    startGame(lobbyId: string | undefined): Promise<void> {
        let url_ = this.baseUrl + "/mainmenu/StartGame?";
        if (lobbyId === null)
            throw new Error("The parameter 'lobbyId' cannot be null.");
        else if (lobbyId !== undefined)
            url_ += "lobbyId=" + encodeURIComponent("" + lobbyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStartGame(_response);
        });
    }

    protected processStartGame(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    login(body: LoginRequest | undefined): Promise<LoginResult> {
        let url_ = this.baseUrl + "/users/Login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogin(_response);
        });
    }

    protected processLogin(response: Response): Promise<LoginResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = LoginResult.fromJS(resultData200, _mappings);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LoginResult>(null as any);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    register(body: RegisterRequest | undefined): Promise<UserDto> {
        let url_ = this.baseUrl + "/users/Register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRegister(_response);
        });
    }

    protected processRegister(response: Response): Promise<UserDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200, _mappings);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserDto>(null as any);
    }

    /**
     * @return Success
     */
    test(): Promise<void> {
        let url_ = this.baseUrl + "/users/test";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTest(_response);
        });
    }

    protected processTest(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class Game implements IGame {
    id?: string;
    nextTick?: Date;
    isActive?: boolean;
    playersInGame!: Player[] | undefined;

    constructor(data?: IGame) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.nextTick = _data["nextTick"] ? new Date(_data["nextTick"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["playersInGame"])) {
                this.playersInGame = [] as any;
                for (let item of _data["playersInGame"])
                    this.playersInGame!.push(Player.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): Game | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<Game>(data, _mappings, Game);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["nextTick"] = this.nextTick ? this.nextTick.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.playersInGame)) {
            data["playersInGame"] = [];
            for (let item of this.playersInGame)
                data["playersInGame"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGame {
    id?: string;
    nextTick?: Date;
    isActive?: boolean;
    playersInGame: Player[] | undefined;
}

export class GameDto implements IGameDto {
    id?: string;
    playersInGameCount?: number;
    created?: Date;

    constructor(data?: IGameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.playersInGameCount = _data["playersInGameCount"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): GameDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<GameDto>(data, _mappings, GameDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["playersInGameCount"] = this.playersInGameCount;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        return data;
    }
}

export interface IGameDto {
    id?: string;
    playersInGameCount?: number;
    created?: Date;
}

export class GameState implements IGameState {
    playerDTO?: PlayerDto | undefined;
    readonly localPlayerRoom?: RoomDTO | undefined;
    newMessages?: Message[] | undefined;
    players?: Player[] | undefined;
    privateChatRoomParticipants?: PrivateChatRoomParticipant[] | undefined;
    logs?: Log[] | undefined;
    rooms?: RoomDTO[] | undefined;
    timeStamp?: Date | undefined;
    serializedLayout?: string | undefined;
    privateChatRooms?: PrivateChatRoom[] | undefined;
    stations?: Station[] | undefined;
    readonly gameId?: string;
    readonly playerUID?: string;

    constructor(data?: IGameState) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.playerDTO = _data["playerDTO"] ? PlayerDto.fromJS(_data["playerDTO"], _mappings) : <any>undefined;
            (<any>this).localPlayerRoom = _data["localPlayerRoom"] ? RoomDTO.fromJS(_data["localPlayerRoom"], _mappings) : <any>undefined;
            if (Array.isArray(_data["newMessages"])) {
                this.newMessages = [] as any;
                for (let item of _data["newMessages"])
                    this.newMessages!.push(Message.fromJS(item, _mappings));
            }
            if (Array.isArray(_data["players"])) {
                this.players = [] as any;
                for (let item of _data["players"])
                    this.players!.push(Player.fromJS(item, _mappings));
            }
            if (Array.isArray(_data["privateChatRoomParticipants"])) {
                this.privateChatRoomParticipants = [] as any;
                for (let item of _data["privateChatRoomParticipants"])
                    this.privateChatRoomParticipants!.push(PrivateChatRoomParticipant.fromJS(item, _mappings));
            }
            if (Array.isArray(_data["logs"])) {
                this.logs = [] as any;
                for (let item of _data["logs"])
                    this.logs!.push(Log.fromJS(item, _mappings));
            }
            if (Array.isArray(_data["rooms"])) {
                this.rooms = [] as any;
                for (let item of _data["rooms"])
                    this.rooms!.push(RoomDTO.fromJS(item, _mappings));
            }
            this.timeStamp = _data["timeStamp"] ? new Date(_data["timeStamp"].toString()) : <any>undefined;
            this.serializedLayout = _data["serializedLayout"];
            if (Array.isArray(_data["privateChatRooms"])) {
                this.privateChatRooms = [] as any;
                for (let item of _data["privateChatRooms"])
                    this.privateChatRooms!.push(PrivateChatRoom.fromJS(item, _mappings));
            }
            if (Array.isArray(_data["stations"])) {
                this.stations = [] as any;
                for (let item of _data["stations"])
                    this.stations!.push(Station.fromJS(item, _mappings));
            }
            (<any>this).gameId = _data["gameId"];
            (<any>this).playerUID = _data["playerUID"];
        }
    }

    static fromJS(data: any, _mappings?: any): GameState | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<GameState>(data, _mappings, GameState);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["playerDTO"] = this.playerDTO ? this.playerDTO.toJSON() : <any>undefined;
        data["localPlayerRoom"] = this.localPlayerRoom ? this.localPlayerRoom.toJSON() : <any>undefined;
        if (Array.isArray(this.newMessages)) {
            data["newMessages"] = [];
            for (let item of this.newMessages)
                data["newMessages"].push(item.toJSON());
        }
        if (Array.isArray(this.players)) {
            data["players"] = [];
            for (let item of this.players)
                data["players"].push(item.toJSON());
        }
        if (Array.isArray(this.privateChatRoomParticipants)) {
            data["privateChatRoomParticipants"] = [];
            for (let item of this.privateChatRoomParticipants)
                data["privateChatRoomParticipants"].push(item.toJSON());
        }
        if (Array.isArray(this.logs)) {
            data["logs"] = [];
            for (let item of this.logs)
                data["logs"].push(item.toJSON());
        }
        if (Array.isArray(this.rooms)) {
            data["rooms"] = [];
            for (let item of this.rooms)
                data["rooms"].push(item.toJSON());
        }
        data["timeStamp"] = this.timeStamp ? this.timeStamp.toISOString() : <any>undefined;
        data["serializedLayout"] = this.serializedLayout;
        if (Array.isArray(this.privateChatRooms)) {
            data["privateChatRooms"] = [];
            for (let item of this.privateChatRooms)
                data["privateChatRooms"].push(item.toJSON());
        }
        if (Array.isArray(this.stations)) {
            data["stations"] = [];
            for (let item of this.stations)
                data["stations"].push(item.toJSON());
        }
        data["gameId"] = this.gameId;
        data["playerUID"] = this.playerUID;
        return data;
    }
}

export interface IGameState {
    playerDTO?: PlayerDto | undefined;
    localPlayerRoom?: RoomDTO | undefined;
    newMessages?: Message[] | undefined;
    players?: Player[] | undefined;
    privateChatRoomParticipants?: PrivateChatRoomParticipant[] | undefined;
    logs?: Log[] | undefined;
    rooms?: RoomDTO[] | undefined;
    timeStamp?: Date | undefined;
    serializedLayout?: string | undefined;
    privateChatRooms?: PrivateChatRoom[] | undefined;
    stations?: Station[] | undefined;
    gameId?: string;
    playerUID?: string;
}

export enum GameTaskCodes {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
    _9 = 9,
    _10 = 10,
    _11 = 11,
    _12 = 12,
    _13 = 13,
    _14 = 14,
    _15 = 15,
    _16 = 16,
    _17 = 17,
    _18 = 18,
    _19 = 19,
    _20 = 20,
    _21 = 21,
    _22 = 22,
}

export class Item implements IItem {
    id?: string;
    ownerId?: string;
    itemType?: ItemType;

    constructor(data?: IItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.ownerId = _data["ownerId"];
            this.itemType = _data["itemType"];
        }
    }

    static fromJS(data: any, _mappings?: any): Item | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<Item>(data, _mappings, Item);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["ownerId"] = this.ownerId;
        data["itemType"] = this.itemType;
        return data;
    }
}

export interface IItem {
    id?: string;
    ownerId?: string;
    itemType?: ItemType;
}

export enum ItemType {
    _0 = 0,
    _1 = 1,
}

export class JoinLobbyRequest implements IJoinLobbyRequest {
    userId?: string;
    lobbyId?: string;

    constructor(data?: IJoinLobbyRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.lobbyId = _data["lobbyId"];
        }
    }

    static fromJS(data: any, _mappings?: any): JoinLobbyRequest | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<JoinLobbyRequest>(data, _mappings, JoinLobbyRequest);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["lobbyId"] = this.lobbyId;
        return data;
    }
}

export interface IJoinLobbyRequest {
    userId?: string;
    lobbyId?: string;
}

export class Lobby implements ILobby {
    id?: string;
    userLobbies?: UserLobby[] | undefined;
    readonly usersInLobby?: User[] | undefined;

    constructor(data?: ILobby) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["userLobbies"])) {
                this.userLobbies = [] as any;
                for (let item of _data["userLobbies"])
                    this.userLobbies!.push(UserLobby.fromJS(item, _mappings));
            }
            if (Array.isArray(_data["usersInLobby"])) {
                (<any>this).usersInLobby = [] as any;
                for (let item of _data["usersInLobby"])
                    (<any>this).usersInLobby!.push(User.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): Lobby | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<Lobby>(data, _mappings, Lobby);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.userLobbies)) {
            data["userLobbies"] = [];
            for (let item of this.userLobbies)
                data["userLobbies"].push(item.toJSON());
        }
        if (Array.isArray(this.usersInLobby)) {
            data["usersInLobby"] = [];
            for (let item of this.usersInLobby)
                data["usersInLobby"].push(item.toJSON());
        }
        return data;
    }
}

export interface ILobby {
    id?: string;
    userLobbies?: UserLobby[] | undefined;
    usersInLobby?: User[] | undefined;
}

export class LobbyDto implements ILobbyDto {
    id?: string;
    usersInLobby?: User[] | undefined;

    constructor(data?: ILobbyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["usersInLobby"])) {
                this.usersInLobby = [] as any;
                for (let item of _data["usersInLobby"])
                    this.usersInLobby!.push(User.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): LobbyDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<LobbyDto>(data, _mappings, LobbyDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.usersInLobby)) {
            data["usersInLobby"] = [];
            for (let item of this.usersInLobby)
                data["usersInLobby"].push(item.toJSON());
        }
        return data;
    }
}

export interface ILobbyDto {
    id?: string;
    usersInLobby?: User[] | undefined;
}

export class Log implements ILog {
    id?: string;
    gameId?: string;
    triggeringPlayerId?: string;
    roomId?: string;
    isPublic?: boolean;
    eventText?: string | undefined;
    created?: Date | undefined;
    createdBy?: string | undefined;

    constructor(data?: ILog) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.gameId = _data["gameId"];
            this.triggeringPlayerId = _data["triggeringPlayerId"];
            this.roomId = _data["roomId"];
            this.isPublic = _data["isPublic"];
            this.eventText = _data["eventText"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
        }
    }

    static fromJS(data: any, _mappings?: any): Log | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<Log>(data, _mappings, Log);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["gameId"] = this.gameId;
        data["triggeringPlayerId"] = this.triggeringPlayerId;
        data["roomId"] = this.roomId;
        data["isPublic"] = this.isPublic;
        data["eventText"] = this.eventText;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        return data;
    }
}

export interface ILog {
    id?: string;
    gameId?: string;
    triggeringPlayerId?: string;
    roomId?: string;
    isPublic?: boolean;
    eventText?: string | undefined;
    created?: Date | undefined;
    createdBy?: string | undefined;
}

export class LoginRequest implements ILoginRequest {
    userName?: string | undefined;
    passwordAttempt?: string | undefined;

    constructor(data?: ILoginRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.passwordAttempt = _data["passwordAttempt"];
        }
    }

    static fromJS(data: any, _mappings?: any): LoginRequest | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<LoginRequest>(data, _mappings, LoginRequest);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["passwordAttempt"] = this.passwordAttempt;
        return data;
    }
}

export interface ILoginRequest {
    userName?: string | undefined;
    passwordAttempt?: string | undefined;
}

export class LoginResult implements ILoginResult {
    token?: string | undefined;
    userId?: string;

    constructor(data?: ILoginResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.token = _data["token"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any, _mappings?: any): LoginResult | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<LoginResult>(data, _mappings, LoginResult);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        data["userId"] = this.userId;
        return data;
    }
}

export interface ILoginResult {
    token?: string | undefined;
    userId?: string
}

export class MainMenuState implements IMainMenuState {
    userDto?: UserDto | undefined;
    timeStamp?: Date | undefined;

    constructor(data?: IMainMenuState) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.userDto = _data["userDto"] ? UserDto.fromJS(_data["userDto"], _mappings) : <any>undefined;
            this.timeStamp = _data["timeStamp"] ? new Date(_data["timeStamp"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): MainMenuState | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<MainMenuState>(data, _mappings, MainMenuState);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userDto"] = this.userDto ? this.userDto.toJSON() : <any>undefined;
        data["timeStamp"] = this.timeStamp ? this.timeStamp.toISOString() : <any>undefined;
        return data;
    }
}

export interface IMainMenuState {
    userDto?: UserDto | undefined;
    timeStamp?: Date | undefined;
}

export class Message implements IMessage {
    id?: string;
    senderName?: string | undefined;
    text?: string | undefined;
    gameId?: string;
    roomId?: string;
    created?: Date | undefined;

    constructor(data?: IMessage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.senderName = _data["senderName"];
            this.text = _data["text"];
            this.gameId = _data["gameId"];
            this.roomId = _data["roomId"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): Message | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<Message>(data, _mappings, Message);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["senderName"] = this.senderName;
        data["text"] = this.text;
        data["gameId"] = this.gameId;
        data["roomId"] = this.roomId;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        return data;
    }
}

export interface IMessage {
    id?: string;
    senderName?: string | undefined;
    text?: string | undefined;
    gameId?: string;
    roomId?: string;
    created?: Date | undefined;
}

export class Player implements IPlayer {
    readonly taskParam?: StringStringValueTuple;
    id?: string;
    currentGameRoomId?: string;
    profession?: RoleType;
    x?: number;
    y?: number;
    z?: number;
    name?: string | undefined;
    healthPoints?: number;
    actionPoints?: number;
    userId?: string;
    user?: User | undefined;
    gameId?: string;
    game?: Game | undefined;

    constructor(data?: IPlayer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            (<any>this).taskParam = _data["taskParam"] ? StringStringValueTuple.fromJS(_data["taskParam"], _mappings) : <any>undefined;
            this.id = _data["id"];
            this.currentGameRoomId = _data["currentGameRoomId"];
            this.profession = _data["profession"];
            this.x = _data["x"];
            this.y = _data["y"];
            this.z = _data["z"];
            this.name = _data["name"];
            this.healthPoints = _data["healthPoints"];
            this.actionPoints = _data["actionPoints"];
            this.userId = _data["userId"];
            this.user = _data["user"] ? User.fromJS(_data["user"], _mappings) : <any>undefined;
            this.gameId = _data["gameId"];
            this.game = _data["game"] ? Game.fromJS(_data["game"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): Player | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<Player>(data, _mappings, Player);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["taskParam"] = this.taskParam ? this.taskParam.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["currentGameRoomId"] = this.currentGameRoomId;
        data["profession"] = this.profession;
        data["x"] = this.x;
        data["y"] = this.y;
        data["z"] = this.z;
        data["name"] = this.name;
        data["healthPoints"] = this.healthPoints;
        data["actionPoints"] = this.actionPoints;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["gameId"] = this.gameId;
        data["game"] = this.game ? this.game.toJSON() : <any>undefined;
        return data;
    }
}

export interface IPlayer {
    taskParam?: StringStringValueTuple;
    id?: string;
    currentGameRoomId?: string;
    profession?: RoleType;
    x?: number;
    y?: number;
    z?: number;
    name?: string | undefined;
    healthPoints?: number;
    actionPoints?: number;
    userId?: string;
    user?: User | undefined;
    gameId?: string;
    game?: Game | undefined;
}

export class PlayerDto implements IPlayerDto {
    id?: string;
    gameId?: string;
    userId?: string;
    currentGameRoomId?: string;
    profession?: RoleType;
    items?: Item[] | undefined;
    skills?: SkillEnum[] | undefined;
    name?: string | undefined;
    x?: number;
    y?: number;
    z?: number;
    healthPoints?: number;
    actionPoints?: number;

    constructor(data?: IPlayerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.gameId = _data["gameId"];
            this.userId = _data["userId"];
            this.currentGameRoomId = _data["currentGameRoomId"];
            this.profession = _data["profession"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Item.fromJS(item, _mappings));
            }
            if (Array.isArray(_data["skills"])) {
                this.skills = [] as any;
                for (let item of _data["skills"])
                    this.skills!.push(item);
            }
            this.name = _data["name"];
            this.x = _data["x"];
            this.y = _data["y"];
            this.z = _data["z"];
            this.healthPoints = _data["healthPoints"];
            this.actionPoints = _data["actionPoints"];
        }
    }

    static fromJS(data: any, _mappings?: any): PlayerDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<PlayerDto>(data, _mappings, PlayerDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["gameId"] = this.gameId;
        data["userId"] = this.userId;
        data["currentGameRoomId"] = this.currentGameRoomId;
        data["profession"] = this.profession;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        if (Array.isArray(this.skills)) {
            data["skills"] = [];
            for (let item of this.skills)
                data["skills"].push(item);
        }
        data["name"] = this.name;
        data["x"] = this.x;
        data["y"] = this.y;
        data["z"] = this.z;
        data["healthPoints"] = this.healthPoints;
        data["actionPoints"] = this.actionPoints;
        return data;
    }
}

export interface IPlayerDto {
    id?: string;
    gameId?: string;
    userId?: string;
    currentGameRoomId?: string;
    profession?: RoleType;
    items?: Item[] | undefined;
    skills?: SkillEnum[] | undefined;
    name?: string | undefined;
    x?: number;
    y?: number;
    z?: number;
    healthPoints?: number;
    actionPoints?: number;
}

export class PrivateChatRoom implements IPrivateChatRoom {
    id?: string;
    chatRoomName?: string | undefined;

    constructor(data?: IPrivateChatRoom) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.chatRoomName = _data["chatRoomName"];
        }
    }

    static fromJS(data: any, _mappings?: any): PrivateChatRoom | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<PrivateChatRoom>(data, _mappings, PrivateChatRoom);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["chatRoomName"] = this.chatRoomName;
        return data;
    }
}

export interface IPrivateChatRoom {
    id?: string;
    chatRoomName?: string | undefined;
}

export class PrivateChatRoomParticipant implements IPrivateChatRoomParticipant {
    id?: string;
    roomId?: string;
    participantId?: string;

    constructor(data?: IPrivateChatRoomParticipant) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.roomId = _data["roomId"];
            this.participantId = _data["participantId"];
        }
    }

    static fromJS(data: any, _mappings?: any): PrivateChatRoomParticipant | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<PrivateChatRoomParticipant>(data, _mappings, PrivateChatRoomParticipant);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["roomId"] = this.roomId;
        data["participantId"] = this.participantId;
        return data;
    }
}

export interface IPrivateChatRoomParticipant {
    id?: string;
    roomId?: string;
    participantId?: string;
}

export class RegisterRequest implements IRegisterRequest {
    userName?: string | undefined;
    password?: string | undefined;
    email?: string | undefined;

    constructor(data?: IRegisterRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.password = _data["password"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any, _mappings?: any): RegisterRequest | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<RegisterRequest>(data, _mappings, RegisterRequest);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["password"] = this.password;
        data["email"] = this.email;
        return data;
    }
}

export interface IRegisterRequest {
    userName?: string | undefined;
    password?: string | undefined;
    email?: string | undefined;
}

export class Role implements IRole {
    id?: string;
    roleName?: RoleName;
    userRoles?: UserRole[] | undefined;

    constructor(data?: IRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.roleName = _data["roleName"];
            if (Array.isArray(_data["userRoles"])) {
                this.userRoles = [] as any;
                for (let item of _data["userRoles"])
                    this.userRoles!.push(UserRole.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): Role | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<Role>(data, _mappings, Role);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["roleName"] = this.roleName;
        if (Array.isArray(this.userRoles)) {
            data["userRoles"] = [];
            for (let item of this.userRoles)
                data["userRoles"].push(item.toJSON());
        }
        return data;
    }
}

export interface IRole {
    id?: string;
    roleName?: RoleName;
    userRoles?: UserRole[] | undefined;
}

export enum RoleName {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export enum RoleType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export class RoomDTO implements IRoomDTO {
    readonly taskParam?: StringStringValueTuple;
    id?: string;
    gameId?: string;
    name?: string | undefined;
    items?: Item[] | undefined;
    players?: Player[] | undefined;
    roomType?: RoomType;
    stations?: Station[] | undefined;
    isLandmass?: boolean;
    x?: number;
    y?: number;

    constructor(data?: IRoomDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            (<any>this).taskParam = _data["taskParam"] ? StringStringValueTuple.fromJS(_data["taskParam"], _mappings) : <any>undefined;
            this.id = _data["id"];
            this.gameId = _data["gameId"];
            this.name = _data["name"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Item.fromJS(item, _mappings));
            }
            if (Array.isArray(_data["players"])) {
                this.players = [] as any;
                for (let item of _data["players"])
                    this.players!.push(Player.fromJS(item, _mappings));
            }
            this.roomType = _data["roomType"];
            if (Array.isArray(_data["stations"])) {
                this.stations = [] as any;
                for (let item of _data["stations"])
                    this.stations!.push(Station.fromJS(item, _mappings));
            }
            this.isLandmass = _data["isLandmass"];
            this.x = _data["x"];
            this.y = _data["y"];
        }
    }

    static fromJS(data: any, _mappings?: any): RoomDTO | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<RoomDTO>(data, _mappings, RoomDTO);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["taskParam"] = this.taskParam ? this.taskParam.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["gameId"] = this.gameId;
        data["name"] = this.name;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        if (Array.isArray(this.players)) {
            data["players"] = [];
            for (let item of this.players)
                data["players"].push(item.toJSON());
        }
        data["roomType"] = this.roomType;
        if (Array.isArray(this.stations)) {
            data["stations"] = [];
            for (let item of this.stations)
                data["stations"].push(item.toJSON());
        }
        data["isLandmass"] = this.isLandmass;
        data["x"] = this.x;
        data["y"] = this.y;
        return data;
    }
}

export interface IRoomDTO {
    taskParam?: StringStringValueTuple;
    id?: string;
    gameId?: string;
    name?: string | undefined;
    items?: Item[] | undefined;
    players?: Player[] | undefined;
    roomType?: RoomType;
    stations?: Station[] | undefined;
    isLandmass?: boolean;
    x?: number;
    y?: number;
}

export enum RoomType {
    _0 = 0,
    _1 = 1,
}

export enum SkillEnum {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export class Station implements IStation {
    readonly taskParam?: StringStringValueTuple;
    id?: string;
    gameId?: string;
    name?: string | undefined;
    serializedProperties?: string | undefined;
    isLandmass?: boolean;
    isActive?: boolean;
    roomName?: string | undefined;

    constructor(data?: IStation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            (<any>this).taskParam = _data["taskParam"] ? StringStringValueTuple.fromJS(_data["taskParam"], _mappings) : <any>undefined;
            this.id = _data["id"];
            this.gameId = _data["gameId"];
            this.name = _data["name"];
            this.serializedProperties = _data["serializedProperties"];
            this.isLandmass = _data["isLandmass"];
            this.isActive = _data["isActive"];
            this.roomName = _data["roomName"];
        }
    }

    static fromJS(data: any, _mappings?: any): Station | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<Station>(data, _mappings, Station);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["taskParam"] = this.taskParam ? this.taskParam.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["gameId"] = this.gameId;
        data["name"] = this.name;
        data["serializedProperties"] = this.serializedProperties;
        data["isLandmass"] = this.isLandmass;
        data["isActive"] = this.isActive;
        data["roomName"] = this.roomName;
        return data;
    }
}

export interface IStation {
    taskParam?: StringStringValueTuple;
    id?: string;
    gameId?: string;
    name?: string | undefined;
    serializedProperties?: string | undefined;
    isLandmass?: boolean;
    isActive?: boolean;
    roomName?: string | undefined;
}

export class StringStringTuple implements IStringStringTuple {
    item1?: string | undefined;
    item2?: string | undefined;

    constructor(data?: IStringStringTuple) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.item1 = _data["item1"];
            this.item2 = _data["item2"];
        }
    }

    static fromJS(data: any, _mappings?: any): StringStringTuple | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<StringStringTuple>(data, _mappings, StringStringTuple);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["item1"] = this.item1;
        data["item2"] = this.item2;
        return data;
    }
}

export interface IStringStringTuple {
    item1?: string | undefined;
    item2?: string | undefined;
}

export class StringStringValueTuple implements IStringStringValueTuple {
    item1?: string | undefined;
    item2?: string | undefined;

    constructor(data?: IStringStringValueTuple) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.item1 = _data["item1"];
            this.item2 = _data["item2"];
        }
    }

    static fromJS(data: any, _mappings?: any): StringStringValueTuple | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<StringStringValueTuple>(data, _mappings, StringStringValueTuple);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["item1"] = this.item1;
        data["item2"] = this.item2;
        return data;
    }
}

export interface IStringStringValueTuple {
    item1?: string | undefined;
    item2?: string | undefined;
}

export class User implements IUser {
    id?: string;
    name?: string | undefined;
    email?: string | undefined;
    passwordHash?: string | undefined;
    players?: Player[] | undefined;
    userRoles?: UserRole[] | undefined;
    userLobbies?: UserLobby[] | undefined;
    readonly lobbies?: Lobby[] | undefined;
    readonly games?: Game[] | undefined;

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.email = _data["email"];
            this.passwordHash = _data["passwordHash"];
            if (Array.isArray(_data["players"])) {
                this.players = [] as any;
                for (let item of _data["players"])
                    this.players!.push(Player.fromJS(item, _mappings));
            }
            if (Array.isArray(_data["userRoles"])) {
                this.userRoles = [] as any;
                for (let item of _data["userRoles"])
                    this.userRoles!.push(UserRole.fromJS(item, _mappings));
            }
            if (Array.isArray(_data["userLobbies"])) {
                this.userLobbies = [] as any;
                for (let item of _data["userLobbies"])
                    this.userLobbies!.push(UserLobby.fromJS(item, _mappings));
            }
            if (Array.isArray(_data["lobbies"])) {
                (<any>this).lobbies = [] as any;
                for (let item of _data["lobbies"])
                    (<any>this).lobbies!.push(Lobby.fromJS(item, _mappings));
            }
            if (Array.isArray(_data["games"])) {
                (<any>this).games = [] as any;
                for (let item of _data["games"])
                    (<any>this).games!.push(Game.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): User | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<User>(data, _mappings, User);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["email"] = this.email;
        data["passwordHash"] = this.passwordHash;
        if (Array.isArray(this.players)) {
            data["players"] = [];
            for (let item of this.players)
                data["players"].push(item.toJSON());
        }
        if (Array.isArray(this.userRoles)) {
            data["userRoles"] = [];
            for (let item of this.userRoles)
                data["userRoles"].push(item.toJSON());
        }
        if (Array.isArray(this.userLobbies)) {
            data["userLobbies"] = [];
            for (let item of this.userLobbies)
                data["userLobbies"].push(item.toJSON());
        }
        if (Array.isArray(this.lobbies)) {
            data["lobbies"] = [];
            for (let item of this.lobbies)
                data["lobbies"].push(item.toJSON());
        }
        if (Array.isArray(this.games)) {
            data["games"] = [];
            for (let item of this.games)
                data["games"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUser {
    id?: string;
    name?: string | undefined;
    email?: string | undefined;
    passwordHash?: string | undefined;
    players?: Player[] | undefined;
    userRoles?: UserRole[] | undefined;
    userLobbies?: UserLobby[] | undefined;
    lobbies?: Lobby[] | undefined;
    games?: Game[] | undefined;
}

export class UserDto implements IUserDto {
    id?: string;
    name?: string | undefined;
    readonly roleNamesAsString?: string[] | undefined;
    roleNames?: RoleName[] | undefined;
    players?: Player[] | undefined;
    queuedLobbies?: LobbyDto[] | undefined;
    activeGames?: GameDto[] | undefined;
    availableLobbies?: Lobby[] | undefined;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["roleNamesAsString"])) {
                (<any>this).roleNamesAsString = [] as any;
                for (let item of _data["roleNamesAsString"])
                    (<any>this).roleNamesAsString!.push(item);
            }
            if (Array.isArray(_data["roleNames"])) {
                this.roleNames = [] as any;
                for (let item of _data["roleNames"])
                    this.roleNames!.push(item);
            }
            if (Array.isArray(_data["players"])) {
                this.players = [] as any;
                for (let item of _data["players"])
                    this.players!.push(Player.fromJS(item, _mappings));
            }
            if (Array.isArray(_data["queuedLobbies"])) {
                this.queuedLobbies = [] as any;
                for (let item of _data["queuedLobbies"])
                    this.queuedLobbies!.push(LobbyDto.fromJS(item, _mappings));
            }
            if (Array.isArray(_data["activeGames"])) {
                this.activeGames = [] as any;
                for (let item of _data["activeGames"])
                    this.activeGames!.push(GameDto.fromJS(item, _mappings));
            }
            if (Array.isArray(_data["availableLobbies"])) {
                this.availableLobbies = [] as any;
                for (let item of _data["availableLobbies"])
                    this.availableLobbies!.push(Lobby.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): UserDto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<UserDto>(data, _mappings, UserDto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.roleNamesAsString)) {
            data["roleNamesAsString"] = [];
            for (let item of this.roleNamesAsString)
                data["roleNamesAsString"].push(item);
        }
        if (Array.isArray(this.roleNames)) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        if (Array.isArray(this.players)) {
            data["players"] = [];
            for (let item of this.players)
                data["players"].push(item.toJSON());
        }
        if (Array.isArray(this.queuedLobbies)) {
            data["queuedLobbies"] = [];
            for (let item of this.queuedLobbies)
                data["queuedLobbies"].push(item.toJSON());
        }
        if (Array.isArray(this.activeGames)) {
            data["activeGames"] = [];
            for (let item of this.activeGames)
                data["activeGames"].push(item.toJSON());
        }
        if (Array.isArray(this.availableLobbies)) {
            data["availableLobbies"] = [];
            for (let item of this.availableLobbies)
                data["availableLobbies"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUserDto {
    id?: string;
    name?: string | undefined;
    roleNamesAsString?: string[] | undefined;
    roleNames?: RoleName[] | undefined;
    players?: Player[] | undefined;
    queuedLobbies?: LobbyDto[] | undefined;
    activeGames?: GameDto[] | undefined;
    availableLobbies?: Lobby[] | undefined;
}

export class UserLobby implements IUserLobby {
    userId?: string;
    user?: User | undefined;
    lobbyId?: string;
    lobby?: Lobby | undefined;
    id?: string;

    constructor(data?: IUserLobby) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.user = _data["user"] ? User.fromJS(_data["user"], _mappings) : <any>undefined;
            this.lobbyId = _data["lobbyId"];
            this.lobby = _data["lobby"] ? Lobby.fromJS(_data["lobby"], _mappings) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any, _mappings?: any): UserLobby | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<UserLobby>(data, _mappings, UserLobby);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["lobbyId"] = this.lobbyId;
        data["lobby"] = this.lobby ? this.lobby.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface IUserLobby {
    userId?: string;
    user?: User | undefined;
    lobbyId?: string;
    lobby?: Lobby | undefined;
    id?: string;
}

export class UserRole implements IUserRole {
    id?: string;
    user?: User | undefined;
    role?: Role | undefined;

    constructor(data?: IUserRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.id = _data["id"];
            this.user = _data["user"] ? User.fromJS(_data["user"], _mappings) : <any>undefined;
            this.role = _data["role"] ? Role.fromJS(_data["role"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): UserRole | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<UserRole>(data, _mappings, UserRole);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUserRole {
    id?: string;
    user?: User | undefined;
    role?: Role | undefined;
}

function jsonParse(json: any, reviver?: any) {
    json = JSON.parse(json, reviver);

    var byid: any = {};
    var refs: any = [];
    json = (function recurse(obj: any, prop?: any, parent?: any) {
        if (typeof obj !== 'object' || !obj)
            return obj;

        if ("$ref" in obj) {
            let ref = obj.$ref;
            if (ref in byid)
                return byid[ref];
            refs.push([parent, prop, ref]);
            return undefined;
        } else if ("$id" in obj) {
            let id = obj.$id;
            delete obj.$id;
            if ("$values" in obj)
                obj = obj.$values;
            byid[id] = obj;
        }

        if (Array.isArray(obj)) {
            obj = obj.map((v, i) => recurse(v, i, obj));
        } else {
            for (var p in obj) {
                if (obj.hasOwnProperty(p) && obj[p] && typeof obj[p] === 'object')
                    obj[p] = recurse(obj[p], p, obj);
            }
        }

        return obj;
    })(json);

    for (let i = 0; i < refs.length; i++) {
        const ref = refs[i];
        ref[0][ref[1]] = byid[ref[2]];
    }

    return json;
}

function createInstance<T>(data: any, mappings: any, type: any): T | null {
  if (!mappings)
    mappings = [];
  if (!data)
    return null;

  const mappingIndexName = "__mappingIndex";
  if (data[mappingIndexName])
    return <T>mappings[data[mappingIndexName]].target;

  data[mappingIndexName] = mappings.length;

  let result: any = new type();
  mappings.push({ source: data, target: result });
  result.init(data, mappings);
  return result;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}
